input {
    stdin {}
}

filter {
    if ([message] =~ "^RUN") {
        grok {
            match => { "message" => "RUN\t%{DATA:simulationClassName}\t%{DATA:userDefinedSimulationId}\t%{DATA:defaultSimulationId}\t%{INT:start}\t%{DATA:description}\t2.0" }
            keep_empty_captures => false
            add_field => { "type" => "RUN" }
        }
        mutate {
            remove_field => ["host", "path"]
        }
        date {
            match => [ "start", "UNIX_MS" ]
        }
    }
    if ([message] =~ "^USER") {
        grok {
            match => { "message" => "USER\t%{DATA:scenario}\t%{INT:userId}\t%{WORD:event}\t%{DATA:startDate}\t%{INT:timestamp}" }
            keep_empty_captures => false
            add_field => { "type" => "USER" }
        }
        mutate {
            remove_field => ["host", "path"]
        }
        date {
            match => [ "timestamp", "UNIX_MS" ]
        }
    }
    if ([message] =~ "^GROUP") {
        drop { }
    }
    if ([message] =~ "^REQUEST") {
        grok {
            match => { "message" => "REQUEST\t%{DATA:scenario_name}\t%{INT:userID}\t%{DATA:group}\t%{DATA:name}\t%{INT:requestStart}\t%{INT:requestEnd}\t%{WORD:status}\t%{DATA:msg}\t%{DATA:method}|%{DATA:url}|%{DATA:file}|%{INT:statusCode}" }
            keep_empty_captures => false
            add_field => { "type" => "REQUEST" }
        }
        mutate {
            gsub => [
                "status", "OK", true,
                "status", "KO", false
            ]
            remove_field => ["host", "path"]
        }
        mutate {
            convert => {
              "status" => "boolean"
              "requestStart" => "integer"
              "requestEnd" => "integer"
            }
        }
        date {
            match => [ "requestStart", "UNIX_MS" ]
        }
        ruby {
            code => "event.set('responseDuration', event.get('requestEnd') - event.get('requestStart'))"
        }
    }
}

output {
     stdout {}
     elasticsearch {
        hosts => {{ groups['elasticsearch'] | tojson(indent=None) | replace("\n", "") }}
        index => "gatling-bd-%{+YYYY.MM.dd.H}"
        codec => "json"
    }
}
