input {
    stdin {}
}

filter {
    if ([message] =~ "^RUN") {
        grok {
            match => { "message" => "RUN\t%{DATA:simulationClass:keyword}\t%{DATA:userId:keyword}\t%{DATA:defaultSimulationId:keyword}\t%{INT:start}\t%{DATA:description:text}\t2.0" }
            keep_empty_captures => false
            add_field => { "type" => "RUN" }
        }
        mutate {
            remove_field => ["host", "path"]
        }
        date {
            match => [ "start", "UNIX_MS" ]
        }
    }
    if ([message] =~ "^USER") {
        grok {
            match => { "message" => "USER\t%{DATA:scenario:keyword}\t%{DATA:userId:keyword}\t%{WORD:event:keyword}\t%{INT:start}\t%{INT:end}" }
            keep_empty_captures => false
            add_field => { "type" => "USER" }
        }
        if ([event] == "START") {
            drop { }
        }
        mutate {
            remove_field => ["host", "path"]
        }
        mutate {
            convert => {
              "start" => "integer"
              "end" => "integer"
            }
        }
        ruby {
            code => "event.set('duration', event.get('end') - event.get('start'))"
        }
        date {
            match => ["start", "UNIX_MS"]
        }
        date {
            match => ["end", "UNIX_MS"]
            target => "end"
        }
    }
    if ([message] =~ "^GROUP") {
        drop { }
    }
    if ([message] =~ "^REQUEST") {
        grok {
            match => { "message" => "REQUEST\t%{DATA:scenario_name:keyword}\t%{INT:userID}\t%{DATA:group}\t%{DATA:name}\t%{INT:requestStart}\t%{INT:requestEnd}\t%{DATA:status:keyword}\t%{DATA:msg}\t%{DATA:method}|%{DATA:url}|%{DATA:file}|%{DATA:statusCode:keyword}" }
            keep_empty_captures => false
            add_field => { "type" => "REQUEST" }
        }
        mutate {
            remove_field => ["host", "path"]
        }
        mutate {
            convert => {
              "start" => "integer"
              "end" => "integer"
            }
        }
        ruby {
            code => "event.set('duration', event.get('end') - event.get('start'))"
        }
        date {
            match => [ "start", "UNIX_MS" ]
        }
        date {
            match => [ "end", "UNIX_MS" ]
            target => "end"
        }
    }
}

output {
     stdout {}
     elasticsearch {
        hosts => {{ groups['elasticsearch'] | tojson(indent=None) | replace("\n", "") }}
        index => "gatling-bd-%{SIM_NAME}-%{+YYYY.MM.dd.H}"
        codec => "json"
    }
}
